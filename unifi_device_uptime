#!/usr/bin/perl
# -*- perl -*-

=encoding utf8

=head1 NAME

unifi_device_uptime - Munin plugin to display uptime for each
ubiquity / unifi device.

=head1 APPLICABLE SYSTEMS

Currently is cabable of polling the unifi line (Ubiquity) from the unifi 
API - requires direct access to the controllor API.

=head1 CONFIGURATION

You will need to supply your API login details - you may do so 
per-plugin, or using a wildcard like below:

  [unifi_*]
    env.user Controller_Username
    # default is ubnt
    env.pass Controller_Password
    # default is ubnt
    env.host https://unifi.fqdn.com:8443
    # default is localhost:8443
    env.sslh no 
    # Check That SSL host is valid, default is yes
    env.sslp no 
    # Check That SSL peer is valid, default is yes
    env.name Site Name
    # A pretty name for the unifi site - used in graph titles.
    env.site site_string 
    # default is "default" - found when you connect to the web interface - 
    # it's the term in the URL - /manage/site/site_string/dashboard

=head1 CAPABILITIES

This plugin supports DIRTYCONFIG : L<http://guide.munin-monitoring.org/en/latest/plugin/protocol-dirtyconfig.html>

=head1 DEPENDENCIES

=over

=item WWW::Curl::Easy

Perl extension interface for libcurl

=item JSON

 JSON (JavaScript Object Notation) encoder/decoder

=back

=head1 LICENSE

Copyright (C) 2018 J.T.Sage (jtsage@gmail.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=head1 VERSION

Most recent version available from 

L<https://github.com/jtsage/unifi-munin-plugins>

=head1 MAGICK MARKERS

  #%# family=manual
  #%# capabilities=autoconf

=cut

use warnings;
use strict;
use utf8;

# Check dependancies
my @errorCode;
my $me = (split '/', $0)[-1];

if (! eval "require JSON;" ) { 	
	push @errorCode, "JSON module not found";
}
if (! eval "require WWW::Curl::Easy;" ) { 
	push @errorCode, "WWW::Curl::Easy module not found";
}

# Provide autoconf info
if ( defined($ARGV[0]) && $ARGV[0] eq "autoconf" ) {
	push @errorCode, "Requires configuration";
	print "no (", join(", " => @errorCode), ")\n";
	exit(0);
}

# Fail on not found dependancies
if ( @errorCode != 0 ) { 
	die "FATAL:$me: Perl dependancies not installed (", join(", " => @errorCode), ")\n";
}

use JSON;
use WWW::Curl::Easy;

# Use multigraph by default, if it's available - allow user override
my $use_multigraph = ( $ENV{MUNIN_CAP_MULTIGRAPH} ) ? (
		( defined $ENV{'multigraph'} && $ENV{'multigraph'} =~ m/no/i ) ? (
			0 # User disabled
		) : (
			1 # Default Option
		)
	) : (
		0 # Not Supported By Munin
	);

# Somewhat (in)sane defaults for host, pass, etc.
#
# Note: SSL checking might not work.  My test rig does not.
my %APIconfig = (
	"user"     => (( defined $ENV{'user'} ) ? $ENV{'user'} : "ubnt"),
	"pass"     => (( defined $ENV{'pass'} ) ? $ENV{'pass'} : "ubnt"),
	"host"     => (( defined $ENV{'host'} ) ? $ENV{'host'} : "https://localhost:8443"),
	"site"     => (( defined $ENV{'site'} ) ? $ENV{'site'} : "default"),
	"sslh"     => (( defined $ENV{'sslh'} ) ? $ENV{'sslh'} : "yes"),
	"sslp"     => (( defined $ENV{'sslp'} ) ? $ENV{'sslp'} : "yes"),
	"name"     => (( defined $ENV{'name'} ) ? $ENV{'name'} : "Unnamed Site"),
);

# Set up needed API endpoints and date strings
my $APILogin  = $APIconfig{"host"} . "/api/login";
my $APILogout = $APIconfig{"host"} . "/api/logout";
my $APIPoint  = $APIconfig{"host"} . "/api/s/" . $APIconfig{"site"} . "/stat/device";
my $APIData   = "{'username':'" . $APIconfig{"user"} . "', 'password':'" . $APIconfig{"pass"} . "'}";
my $APISSLHst = ( $APIconfig{"sslh"} =~ m/no/i ) ? 0 : 2;
my $APISSLPer = ( $APIconfig{"sslp"} =~ m/no/i ) ? 0 : 1;
my $APIRawResp; my $APILogResp; my $ignore;

# Init curl.
my $curl= WWW::Curl::Easy->new() or die "FATAL:$me: WWW::Curl::Easy init failed!\n";
my $retcode;

# Set up curl, and login to API
$curl->setopt(CURLOPT_POST,1);
$curl->setopt(CURLOPT_COOKIEFILE,"");  # Session only cookie.
$curl->setopt(CURLOPT_SSL_VERIFYPEER, $APISSLPer);
$curl->setopt(CURLOPT_SSL_VERIFYHOST, $APISSLHst);
$curl->setopt(CURL_SSLVERSION_TLSv1, 1);
$curl->setopt(CURLOPT_URL, $APILogin);
$curl->setopt(CURLOPT_POSTFIELDS, $APIData );
$curl->setopt(CURLOPT_WRITEDATA, \$APILogResp);
$retcode = $curl->perform;

if ( $retcode != 0 ) { 
	die "FATAL:$me: Unable to connect to API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

my $jsonLogOBJ = new JSON or die "FATAL:$me: JSON init failed!\n";
my $jsonLogResp = $jsonLogOBJ->allow_nonref->utf8->relaxed->decode($APILogResp);
if ( $jsonLogResp->{"meta"}->{"rc"} ne "ok" ) {
	die "FATAL:$me: Unable to login to API - it said: " , $jsonLogResp->{"meta"}->{"msg"} , "\n";
}


# Get some API data.
$curl->setopt(CURLOPT_HTTPGET,1);
$curl->setopt(CURLOPT_WRITEDATA, \$APIRawResp);
$curl->setopt(CURLOPT_URL, $APIPoint);
$retcode = $curl->perform;

# Decode response
my $jsonOBJ = new JSON or die "FATAL:$me: JSON init failed!\n";
my $jsonResp = $jsonOBJ->allow_nonref->utf8->relaxed->decode($APIRawResp);

if ( $retcode != 0 ) { 
	die "FATAL:$me: Unable to fetch data from API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}


# Log back out. (Should invalidate our cookie file, just in case)
$curl->setopt(CURLOPT_HTTPGET,1);
$curl->setopt(CURLOPT_WRITEDATA, \$ignore);
$curl->setopt(CURLOPT_URL, $APILogout);
$retcode = $curl->perform;

if ( $retcode != 0 ) { 
	die "FATAL:$me: Unable to logout of API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

# Work with the API data - grab everything we will need.
my %deviceList;

foreach ( @{$jsonResp->{"data"}} ) {
	$deviceList{ make_safe( $_->{"name"} ) } = {
		"name" => $_->{"name"},
		"value" => $_->{'uptime'}
	};
}

if ( defined($ARGV[0]) && $ARGV[0] eq "config" ) {
	print "graph_title Uptime : " , $APIconfig{"name"} , "\n";
	print "graph_args --base 1000 -r --lower-limit 0\n";
	print "graph_vlabel days\n";
	print "graph_category unifi\n";

	foreach ( sort keys %deviceList ) {
		print $_ , ".label " , $deviceList{$_}->{"name"} , "\n";
		if ( $ENV{"MUNIN_CAP_DIRTYCONFIG"} ) {
			print $_ , ".value " , ( $deviceList{$_}->{"value"} / 86400 ) , "\n";
		}
	}
	exit 0;

} else {
	foreach ( sort keys %deviceList ) {
		print $_ , ".value " , ( $deviceList{$_}->{"value"} / 86400 ) , "\n";
	}
}

sub make_safe { $_ = shift(@_); s/\W/_/g; return lc; } #munin-node safe name